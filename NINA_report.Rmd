---
title: "NINA"
author: "Javier Arambula Rascon"
format: pdf
editor: visual
---

# Package Installation

```{r}
# In order to create a PDF we need to set a CRAN mirror
options(repos = c(CRAN = "http://cran.rstudio.com/"))
```

The following code is used to download all libraries necessary for this analysis. Differential gene expression is performed using DEseq2 with plotting done with ggplot2.

```{r, echo = FALSE, message = FALSE}
# install bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE)) {
  install.packages("BiocManager")
}

if (!requireNamespace("DESeq2", quietly = TRUE)) {
  BiocManager::install("DESeq2")
}

if (!requireNamespace("topGO", quietly = TRUE)) {
  BiocManager::install("topGO")
}

if (!requireNamespace("clusterProfiler", quietly = TRUE)) {
  BiocManager::install("clusterProfiler")
}

# if (!requireNamespace("KEGGREST", quietly = TRUE)) {
#   BiocManager::install("KEGGREST")
# }

# install CRAN packages
if (!requireNamespace("ggplot2", quietly = TRUE)) {
  install.packages("ggplot2")
}

if (!requireNamespace("ggVennDiagram", quietly = TRUE)) {
  install.packages("ggVennDiagram")
}

if (!requireNamespace("tidyr", quietly = TRUE)) {
  install.packages("tidyr")
}

if (!requireNamespace("dplyr", quietly = TRUE)) {
  install.packages("dplyr")
}

if (!requireNamespace("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel")
}
if (requireNamespace("progress", quietly = TRUE)) {
  install.packages("progress")
}

if (!requireNamespace("cowplot", quietly = TRUE)) {
  install.packages("cowplot")
}

if (!requireNamespace("gt", quietly = TRUE)) {
  install.packages("gt")
}

if (!requireNamespace("webshot2", quietly = TRUE)) {
  install.packages("webshot2")
}
```

# Loading Libraries

This section of code loads the necessary libraries.

```{r, echo = FALSE, message = FALSE}
# load libraries
library("DESeq2")
library("ggplot2")
library("topGO")
library("clusterProfiler")
library("tidyr")
library("topGO")
library("ggrepel")
library("ggVennDiagram")
library("dplyr")
# library("KEGGREST")
library("progress") 
library("cowplot")
library("gt")
library("webshot2")
```

# Data Import

The following code is used to import the data for DEG analysis. The text file produced from feature counts is imported as the raw table. The table is cleaned of unnecessary rows, ie meta-data.

The row names then need to be set for the genes list or else DESeq2 will not work. It only takes numbers as input and extra information not in the form of a column or row name will result in an error message.

The first column contains a set of numbers that corresponds to the row number and needs to be removed before the gene list can be assigned as the row name.

Coldata refers to column data, ie. the meta data needed to perform analysis. This table has information about each analyzed fastq file and the treatment it received. In this case a control, NINA treated at 24 and 48 hours, and treatment with bacterial cells for 24 and 48 hours.

Similarly to the featurecounts data, the column-data needed reformatting with row names corresponding to each fastq file in order.

The final line is a way to confirm that the columns in the feature count table correspond with the rows of the coldata table.

```{r, echo = FALSE}
# We read in the file as a tsv
featurecounts_raw <- read.delim("feature_counts.txt",
                                sep = "\t",
                                header = TRUE)

# Column clean up step
cleanfeatures <- featurecounts_raw[-c(2, 3, 4, 5, 6)]

# Removes the first column
counts <- cleanfeatures[, -1]

# We need to set rownames for our count matrix
rownames(counts) <- cleanfeatures[, 1]

# We now import our column metadata
coldata <- read.csv("coldata.csv", header = TRUE)

# set row names for coldata
rownames(coldata) <- coldata$X # the name of the column is X
```

# Column and Row Sanity Check

The following snippet of codes checks to see if columns and rows match for the coldata and cleaned and formatted counts matrix. It should print TRUE.

```{r}
# We now test to see if rownames and columnnames match for meta data and counts matrix
all(rownames(coldata) == colnames(counts))
```

# DEG Analysis

The following snippet of code performs the DEG analysis.

The first snippet creates an object called dds, ie. DESeqDataSet. The parameters include the data, in this case it was the counts object we created in the last code block with the gene list as the row names. The column data is the coldata object we created and reformatted. Finally, the design includes the column name for the coldata object holding our experimental design, ie. treatment type.

The second line of code sets the control group as the reference for differential expression analysis.

```{r, echo = FALSE}
# We create a DeseqDataSet or DDS
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = coldata,
                              design = ~ Treatment)

# We set our control as reference
dds$Treatment <- relevel(dds$Treatment, ref = "control")
dds

# We can now perform DEG
dds <- DESeq(dds)

# We now need to create a results dataframe
results <- results(dds)
```

# Sanity Check for Successful DEG Analysis

The following code prints all results as a double check to make sure the proper comparisons were made.

```{r}
# We print results to the console
results

# We do the same for the summary of our results
summary(results)

# This prints pairwise comparisons, another useful double check
resultsNames(dds)
```

# PCA Plot

The following snippet of code is crucial for testing the quality of our data.

We need to apply the variance stabilizing method provided by `DESeq2` in order to stabilize our data for PCA plotting. By default, the `vst` method uses the top 500 genes in terms of variance for the analysis. This can be modified using the `ntop = foo` option, The `blind = TRUE` option is important, as it allows you to see the variance across groups.

The next line of code creates an object called `pca_data` that stores the output from the `plotPCA` method provided by `DESEq2`. It uses our variance stabilized `vsd` object with the `intgroup` parameter referring to experimental design, and `returnData` set to `TRUE`.

We can then extract the percent of variance for each principal component for plotting.

```{r}
# We create an output directory to save results
dir.create("DEG_results", showWarnings = FALSE)

# We perform VST transformation
vsd <- vst(dds, blind = TRUE)
pca_data <- plotPCA(vsd, intgroup = c("Treatment"), returnData = TRUE)
percent_var <- round(100 * attr(pca_data, "percentVar"))

# PCA plotting using ggplot2
pca <- ggplot(pca_data, aes(PC1, PC2, color = Treatment)) +
  geom_point(size = 3, alpha = 0.8) +
  xlab(paste0("PC1: ", percent_var[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var[2], "% variance")) +
  coord_fixed() +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 14) +
  theme(
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )

# Saves our plot to result directory
ggsave("DEG_results/pca_plot.png", plot = pca, width = 6, height = 6, dpi = 300)

# We can now view our PCA plot
pca
```

Each comparison is closely clustered together, demonstrating proper sample similarity. This is an important check that ensures our samples are comparable and that external variance will not skew results.

# Venn Diagrams

We can now plot a simple venn-diagram to visualize the number of differentially expressed genes per pair-wise comparisons and to draw contrasts between them.

```{r}
# We perform a small cleanup of the resultNames and store into a variable comparisons
comparisons <- resultsNames(dds)[-1]

# We initialize a list to store results
all_degs <- list()

# We loop through each pair-wise comparison
for (comp in comparisons) {
  
  # We store results for each comparison
  res <- results(dds, name = comp)
  
  # We can now filter for adjusted p-values and drop NA rows
  sig <- res[which(res$padj < 0.05 & !is.na(res$padj)), ]

  # We use the abs() method to find absolute values to capture both up and down regulated genes
  all <- rownames(sig[abs(sig$log2FoldChange) > 1.5, ])

  # We now store our comparison to our list
  all_degs[[comp]] <- all
}

# We can now create a ggVennDiagram of our extracted DEGs
all_venn <- ggVennDiagram(all_degs, label_alpha = 0, edge_size = 0.5,
                          label = "count",
                          #label_size = 5,
                          category.names = c("Cells 24H", # cells vs control 24H
                                             "Cells 48H", # cells vs control 48h
                                             "Supernatant 24H", # supernatant vs c 24h
                                             "Supernatant 48H")) + # supernatant vs c 48
  theme(text = element_text(size = 5, face = "bold")) +
  scale_fill_distiller(palette = "Spectral") +
  labs(title = "") +
  theme(text = element_text(size = 10),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"))

# We need to apply a small fix to our labels since they are too long
fixed_venn <- all_venn + scale_x_continuous(expand = expansion(mult = 0.2))

# Save our plot to results
ggsave("DEG_results/all_DEGs_venn.png",
       plot = fixed_venn, dpi = 600, width = 10, height = 8)

# We now display our plot
fixed_venn
```

# Extraction of Individual Comparisons

Some of the following analyses involve the individual pair-wise comparisons, so in this section I am extracting them and stored them as data frames.

```{r, echo = FALSE}
# We need to store comparison names
cell_24_control <- resultsNames(dds)[-c(1,3,4,5)] # this part is pretty confusing
cell_48_control <- resultsNames(dds)[-c(1,2,4,5)] # what i am doing is removing..
nina_24_control <- resultsNames(dds)[-c(1,2,3,5)] # the different indices to leave..
nina_48_control <- resultsNames(dds)[-c(1,2,3,4)] # the one I am interested in

# We store results for each comparison
resC24 <- results(dds, name = cell_24_control)
resC48 <- results(dds, name = cell_48_control) 
resN24 <- results(dds, name = nina_24_control)
resN48 <- results(dds, name = nina_48_control)

# We now filter the data for NA values
resC24_df <- as.data.frame(resC24) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))
resC48_df <- as.data.frame(resC48) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))
resN24_df <- as.data.frame(resN24) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))
resN48_df <- as.data.frame(resN48) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))

# We can then add columns for up, down, and no-sig
resC24_df$diffexpress <- "NO" # initializes column with no as default
resC24_df$diffexpress[resC24_df$padj < 0.05 & resC24_df$log2FoldChange > 1.5] <- "UP"
resC24_df$diffexpress[resC24_df$padj < 0.05 & resC24_df$log2FoldChange < -1.5] <- "DOWN"

resC48_df$diffexpress <- "NO" # initializes column with no as default
resC48_df$diffexpress[resC48_df$padj < 0.05 & resC48_df$log2FoldChange > 1.5] <- "UP"
resC48_df$diffexpress[resC48_df$padj < 0.05 & resC48_df$log2FoldChange < -1.5] <- "DOWN"

resN24_df$diffexpress <- "NO" # initializes column with no as default
resN24_df$diffexpress[resN24_df$padj < 0.05 & resN24_df$log2FoldChange > 1.5] <- "UP"
resN24_df$diffexpress[resN24_df$padj < 0.05 & resN24_df$log2FoldChange < -1.5] <- "DOWN"

resN48_df$diffexpress <- "NO" # initializes column with no as default
resN48_df$diffexpress[resN48_df$padj < 0.05 & resN48_df$log2FoldChange > 1.5] <- "UP"
resN48_df$diffexpress[resN48_df$padj < 0.05 & resN48_df$log2FoldChange < -1.5] <- "DOWN"

# Now we need to convert row names to columns
resC24_df$gene_id <- rownames(resC24_df)
resC48_df$gene_id <- rownames(resC48_df)
resN24_df$gene_id <- rownames(resN24_df)
resN48_df$gene_id <- rownames(resN48_df)
```

# Volcano Plots

We can now create volcano plots for each pairwise comparison. These will demonstrate which treatment has the highest number of upregulated/downregulated genes. This will allow us to see which treatment and time period has the most impact in the early actinorhizal interaction.

```{r}
# Helper function for volcano plots
volc_plotter <- function(result_frame, title) {
  volc_plot <- ggplot(data = result_frame, 
                        aes(x = log2FoldChange, 
                            y = -log10(padj), 
                            col = diffexpress)) +
  geom_vline(xintercept = c(-1.5, 1.5), col = "gray", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = "dashed") +
  geom_point(size = 2) +
  scale_color_manual(values = c("blue","grey","red"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) +
  coord_cartesian(ylim = c(0, 40), xlim = c(-10, 10)) +
  labs(color = "Legend", 
       x = expression("log"[2]*"FC"), 
       y = expression("-log"[10]*"p-value")) +
  ggtitle(title) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
  return(volc_plot)
}

# We can now apply the function to the results dfs
volc_cells_24 <- volc_plotter(resC24_df, "Cells vs. Control 24H")
volc_cells_48 <- volc_plotter(resC48_df, "Cells vs. Control 48H")
volc_NINA_24 <- volc_plotter(resN24_df, "NINA vs. Control 24H")
volc_NINA_48 <- volc_plotter(resN48_df, "NINA vs. Control 48H")

# Save the plot to results directory
ggsave("DEG_results/cellsv24.png", plot = volc_cells_24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/cellsv48.png", plot = volc_cells_48, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/superv24.png", plot = volc_NINA_24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/superv48.png", plot = volc_NINA_48, dpi = 600, width = 10, height = 8)

# We can now visualize our plots
volc_cells_24
volc_cells_48
volc_NINA_24
volc_NINA_48
```

```{r}
# Now we can merge all the figures into one multi-panel figure

# We first cleanup legends
volc_cells_24 <- volc_cells_24 + theme(legend.position = "none")
volc_cells_48 <- volc_cells_48 + theme(legend.position = "none")
volc_NINA_24 <- volc_NINA_24  + theme(legend.position = "none")
volc_NINA_48 <- volc_NINA_48 + theme(legend.position = "none")

# Use cowplots plot_grid method
comb_volc_first <- plot_grid(volc_cells_24, volc_cells_48, volc_NINA_24, volc_NINA_48, 
                             labels = c("A","B","C","D"),
                             ncol = 2,
                             align = "hv")
# Save the plot to results directory
ggsave("DEG_results/final_volcano_clean.png", 
       plot = comb_volc_first, dpi = 600, width = 10, height = 8)

# We now visualize our plot
comb_volc_first
```

# Loading in eggnog-mapper annotations

Now that we have a general understanding of the impact on global gene expression NINA/*Frankia* treatment have on the root tissue, we need to complete functional annotations and enrichment analysis to better understand the specific pathways involved. I performed annotations using eggnog-mapper, the script can be found on my github [casuarina-frankie](https://github.com/aram2608/casuarina-frankie).

```{r}
# Load in our data
annotation_data <- read.delim("dups_removed_viridae.tsv", sep = "\t", header = TRUE, check.names = FALSE)
```

# GO Enrichment

In order to complete gene ontology enrichment, we need to create a gene universe of all the annotated genes in our study. This will give us a background set of genes for our enrichment test to work.

```{r}
# Going to create our gene universe from the eggnog mapper output
go_terms <- annotation_data[c(1,10)]
go_terms <- go_terms[go_terms$GOs != "-",]

# We export out our go terms to a tsv file
write.table(go_terms, file = "go_terms.tsv", sep = "\t", quote = FALSE, row.names = FALSE)

# Here we are loading back in our file with the readMappings function
gene2goMappings <- readMappings(file = "go_terms.tsv", sep = "\t", IDsep = ",")
```

Now that our universe is created, we can annotated our data-frames with the GO terms and filter out any genes with NA values.

```{r}
# We create our annotated data frame
go_C24 <- merge(resC24_df, go_terms[, c("query", "GOs")], by.x = "gene_id", by.y = "query", all.x = TRUE)
go_C48 <-merge(resC48_df, go_terms[, c("query", "GOs")], by.x = "gene_id", by.y = "query", all.x = TRUE)
go_N24 <- merge(resN24_df, go_terms[, c("query", "GOs")], by.x = "gene_id", by.y = "query", all.x = TRUE)
go_N48 <- merge(resN48_df, go_terms[, c("query", "GOs")], by.x = "gene_id", by.y = "query", all.x = TRUE)

# We can now filter out all NAs
go_C24 <- go_C24[!is.na(go_C24$GOs),]
go_C48 <- go_C48[!is.na(go_C48$GOs),]
go_N24 <- go_N24[!is.na(go_N24$GOs),]
go_N48 <- go_N48[!is.na(go_N48$GOs),]

# We now need to extract all genes with lof2FoldChange above 1.5
go_C24 <- go_C24 %>%
  filter(abs(log2FoldChange) > 1.5)

go_C48 <- go_C48 %>%
  filter(abs(log2FoldChange) > 1.5)

go_N24 <- go_N24 %>%
  filter(abs(log2FoldChange) > 1.5)

go_N48 <- go_N48 %>%
  filter(abs(log2FoldChange) > 1.5)

# Extract gene IDs and p-values
Cp24 <- dplyr::select(go_C24, gene_id,padj)
Cp48 <- dplyr::select(go_C48, gene_id,padj)
Np24 <- dplyr::select(go_N24, gene_id,padj)
Np48 <- dplyr::select(go_N48, gene_id,padj)

# We need to sort by p-value for topgo to work properly
sorted_Cp24 <- Cp24[order(Cp24$padj),]
sorted_Cp48 <- Cp48[order(Cp48$padj),]
sorted_Np24 <- Np24[order(Np24$padj),]
sorted_Np48 <- Np48[order(Np48$padj),]

# WE now need to convert to topGOs genelist format
topgo_Cp24 <- sorted_Cp24$padj
topgo_Cp48 <- sorted_Cp48$padj
topgo_Np24 <- sorted_Np24$padj
topgo_Np48 <- sorted_Np48$padj

# Now we can provide topgo vector with a name
names(topgo_Cp24) <- sorted_Cp24$gene_id
names(topgo_Cp48) <- sorted_Cp48$gene_id
names(topgo_Np24) <- sorted_Np24$gene_id
names(topgo_Np48) <- sorted_Np48$gene_id

# This is a hard coded p-value cutoff for our filtering function
# topGO requires this function or else the enrichment will not work
padj_cut <- 0.05

# functions for filtering significant genes
topgo_filter_func <- function(x) {
  return(x <= padj_cut)
}
```

# Creating GO data objects for enrichment tests

Now we have a bit more code to get through before we can complete enrichment. We need to create GO data objects that are used in the enrichment tests.

```{r}
# First I am going to create some helper functions to minimize the amount of boiler plate needed
go_mf <- function(topgo_object) {
  mf <- new("topGOdata", 
               ontology = "MF", 
               allGenes = topgo_object, 
               annot = annFUN.gene2GO, 
               geneSel = topgo_filter_func,
               gene2GO = gene2goMappings)
  return(mf)
}

go_bp <- function(topgo_object) {
  bp <- new("topGOdata", 
               ontology = "BP", 
               allGenes = topgo_object, 
               annot = annFUN.gene2GO, 
               geneSel = topgo_filter_func,
               gene2GO = gene2goMappings)
  return(bp)
}

go_cc <- function(topgo_object) {
  cc <- new("topGOdata", 
               ontology = "CC", 
               allGenes = topgo_object, 
               annot = annFUN.gene2GO, 
               geneSel = topgo_filter_func,
               gene2GO = gene2goMappings)
  return(cc)
}
```

```{r}
# We apply the functions to each pairwise comparisons

# Cells vs control 24
Cp24_go_mf <- go_mf(topgo_Cp24)
Cp24_go_bp <- go_bp(topgo_Cp24)
Cp24_go_cc <- go_cc(topgo_Cp24)

# NINA vs control 24
Np24_go_mf <- go_mf(topgo_Np24)
Np24_go_bp <- go_bp(topgo_Np24)
Np24_go_cc <- go_cc(topgo_Np24)

# Cells vs control 48
Cp48_go_mf <- go_mf(topgo_Cp48)
Cp48_go_bp <- go_bp(topgo_Cp48)
Cp48_go_cc <- go_cc(topgo_Cp48)

# NINA vs control 48
Np48_go_mf <- go_mf(topgo_Np48)
Np48_go_bp <- go_bp(topgo_Np48)
Np48_go_cc <- go_cc(topgo_Np48)
```

# Running Fisher's Test for Enrichment and Plotting

I'm back with a better understanding, the classic algorithm for the Fisher's exact test is exactly what i sounds like, just a standard fishers test, the elim and weighted algorithms are a bit different in that they take into account the GO hierarchy, ie ancestral/parent terms and child terms.

You need to play around with the parameters a bit to see what works best, but ultimately just pick one and stick with it as you do not want to p-value hack. I personally prefer the weight01 and elim options since they seem to give the most informative go terms.

```{r, echo=FALSE,message=FALSE}
# Helper function that wraps the runTest function for ease of use
elim_fisher <- function(go_object) {
  fishy <- runTest(go_object, algorithm = "weight01", statistic = "fisher")
  return(fishy)
}

# Enrichment tests for molecular function
fisher_Cp24_mf <- elim_fisher(Cp24_go_mf)
fisher_Cp48_mf <- elim_fisher(Cp48_go_mf)
fisher_Np24_mf <- elim_fisher(Np24_go_mf)
fisher_Np48_mf <- elim_fisher(Np48_go_mf)

# Enrichment tests for biological process
fisher_Cp24_bp <- elim_fisher(Cp24_go_bp)
fisher_Cp48_bp <- elim_fisher(Cp48_go_bp)
fisher_Np24_bp <- elim_fisher(Np24_go_bp)
fisher_Np48_bp <- elim_fisher(Np48_go_bp)

# Enrichment test for cellular component
fisher_Cp24_cc <- elim_fisher(Cp24_go_cc)
fisher_Cp48_cc <- elim_fisher(Cp48_go_cc)
fisher_Np24_cc <- elim_fisher(Np24_go_cc)
fisher_Np48_cc <- elim_fisher(Np48_go_cc)
```

Now we need to create a table to store our enrichment results.

```{r, echo=FALSE,message=FALSE}
# Helper function to generate a nicely formatted enrichment table
get_enrich_table <- function(go_obj, fisher_result, total_genes = NULL) {
  tab <- GenTable(go_obj,
                  classicFisher = fisher_result,
                  orderBy = "classicFisher", # orders results by sig p-values
                  ranksOf = "classicFisher",
                  topNodes = 10) %>% # topNodes = length(score(fisher_result)))
    mutate(
      pvalue = as.numeric(classicFisher),
      Term = factor(Term, levels = rev(unique(Term))),
      Count = as.numeric(Significant),
      GeneRatio = if (!is.null(total_genes)) Count / total_genes else NA_real_
    ) %>%
    select(Term, Count, GeneRatio, pvalue, everything()) %>%
    arrange(pvalue)

  return(tab)
}
```

Now we can apply our helper function to each enrichment results and create a table for plotting.

```{r}
# Molecular Function (MF)
tab_Cp24_mf <- get_enrich_table(Cp24_go_mf, 
                                fisher_Cp24_mf
                                )

tab_Cp48_mf <- get_enrich_table(Cp48_go_mf, 
                                fisher_Cp48_mf
                                )

tab_Np24_mf <- get_enrich_table(Np24_go_mf, 
                                fisher_Np24_mf
                                )

tab_Np48_mf <- get_enrich_table(Np48_go_mf, 
                                fisher_Np48_mf
                                )

# Biological Process (BP)
tab_Cp24_bp <- get_enrich_table(Cp24_go_bp, 
                                fisher_Cp24_bp
                                )

tab_Cp48_bp <- get_enrich_table(Cp48_go_bp, 
                                fisher_Cp48_bp
                                )

tab_Np24_bp <- get_enrich_table(Np24_go_bp, 
                                fisher_Np24_bp
                                )

tab_Np48_bp <- get_enrich_table(Np48_go_bp, 
                                fisher_Np48_bp
                                )

# Cellular Component (CC)
tab_Cp24_cc <- get_enrich_table(Cp24_go_cc, 
                                fisher_Cp24_cc
                                )

tab_Cp48_cc <- get_enrich_table(Cp48_go_cc, 
                                fisher_Cp48_cc
                                )

tab_Np24_cc <- get_enrich_table(Np24_go_cc, 
                                fisher_Np24_cc
                                )

tab_Np48_cc <- get_enrich_table(Np48_go_cc, 
                                fisher_Np48_cc
                                )
```

We can now create plots for our enriched terms. First we need to make a helper function to minimize the amount of boiler plate code written.

```{r}
# Helper function for plotting enriched terms
plot_enrich_bar <- function(enrich_tab, title = "") {
  enrich_tab <- enrich_tab %>%
    
    # We filter by p-value
    filter(pvalue < 0.05) %>%

    # We arrange bars by p-value
    arrange(pvalue) %>%
    
    # Mutate values for plotting
    mutate(
      Term = factor(Term, levels = rev(unique(Term))),
      Count = as.numeric(Count),
      pvalue = as.numeric(pvalue)
    )

  # Plotting method
  ggplot(enrich_tab, aes(x = Count, y = Term, fill = pvalue)) +
    geom_bar(stat = "identity") +
    scale_fill_gradient(low = "red", high = "blue", name = "p-value") +
    labs(
      title = title,
      x = "Gene Count",
      y = NULL
    ) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5, face = "bold"),
      axis.text.y = element_text(size = 10),
      axis.title.x = element_text(size = 12),
      legend.title = element_text(size = 10),
      legend.text = element_text(size = 9)
    )
}
```

# Creating plots

```{r}
# MF plots
go_MF_graph_C24 <- plot_enrich_bar(tab_Cp24_mf, "MF Cells vs. Control 24H")
go_MF_graph_C48 <- plot_enrich_bar(tab_Cp48_mf, "MF Cells vs. Control 48H")
go_MF_graph_N24 <- plot_enrich_bar(tab_Np24_mf, "MF Supernatant vs. Control 24H")
go_MF_graph_n48 <- plot_enrich_bar(tab_Np48_mf, "MF Supernatant vs. Control 48H")

# BP plots
go_bp_graph_C24 <- plot_enrich_bar(tab_Cp24_bp, "BP Cells vs. Control 24H")
go_bp_graph_C48 <- plot_enrich_bar(tab_Cp48_bp, "BP Cells vs. Control 48H")
go_bp_graph_N24 <- plot_enrich_bar(tab_Np24_bp, "BP Supernatant vs. Control 24H")
go_bp_graph_N48 <- plot_enrich_bar(tab_Np48_bp, "BP Supernatant vs. Control 48H")

# CC plots
go_CC_graph_C24 <- plot_enrich_bar(tab_Cp24_cc, "CC Cells vs. Control 24H")
go_CC_graph_C48 <- plot_enrich_bar(tab_Cp48_cc, "CC Cells vs. Control 48H")
go_CC_graph_N24 <- plot_enrich_bar(tab_Np24_cc, "CC Supernatant vs. Control 24H")
go_CC_graph_N48 <- plot_enrich_bar(tab_Np48_cc, "CC Supernatant vs. Control 48H")

# plot to markdown
go_MF_graph_C24
go_MF_graph_C48
go_MF_graph_N24
go_MF_graph_n48

go_bp_graph_C24
go_bp_graph_C48
go_bp_graph_N24
go_bp_graph_N48

go_CC_graph_C24
go_CC_graph_C48
go_CC_graph_N24
go_CC_graph_N48
```

```{r}
# We save the graphs to the results directory
ggsave("DEG_results/go_MF_C24.png",
       plot = go_MF_graph_C24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_MF_C48.png",
       plot = go_MF_graph_C48, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_MF_N24.png",
       plot = go_MF_graph_N24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_MF_N48.png",
       plot = go_MF_graph_n48, dpi = 600, width = 10, height = 8)

ggsave("DEG_results/go_bp_C24.png",
       plot = go_bp_graph_C24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_bp_C48.png",
       plot = go_bp_graph_C48, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_bp_N24.png",
       plot = go_bp_graph_N24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_bp_N48.png",
       plot = go_bp_graph_N48, dpi = 600, width = 10, height = 8)

ggsave("DEG_results/go_CC_C24.png",
       plot = go_CC_graph_C24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_CC_C48.png",
       plot = go_CC_graph_C48, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_CC_N24.png",
       plot = go_CC_graph_N24, dpi = 600, width = 10, height = 8)
ggsave("DEG_results/go_CC_N48.png",
       plot = go_CC_graph_N48, dpi = 600, width = 10, height = 8)
```

# COG Distribution

We can now see that the treatment with cells has a much more profound effect on the root tissue, especially in the first 24 hours. We have also discovered that the most common response type in the first 24 hours appears to be defense related, irregardless of treatment with NINA or *Frankia*. This makes sense as *Frankia* likely emits compounds similar to other bacteria with more pathogenic natures. Following the likely recognition of NINA, the response diminishes at 48 hours. Interstingly, the response to antibiotics is enriched which is intriguing given the similarities NINA possesses with peptides, many of which can be antibiotic like compounds in Gram-positive bacteria, especially actinobacteria.

Given these findings we can continue to search for more patterns in transcription, with one way being plotting of COG terms. These terms can provide a perspective on which conserved biological processes are common across pair-wise comparisons.

```{r}
# We first must extract all upregulated DEGs
upreg_C24 <- resC24_df %>%
  filter(log2FoldChange > 1.5, padj < 0.5)

upreg_C48 <- resC48_df %>%
  filter(log2FoldChange > 1.5, padj < 0.05)

upreg_N24 <- resN24_df %>%
  filter(log2FoldChange > 1.5, padj < 0.05)

upreg_N48 <- resN48_df %>%
  filter(log2FoldChange > 1.5, padj < 0.05)

# Same with downreg
downreg_C24 <- resC24_df %>%
  filter(log2FoldChange < -1.5, padj < 0.05)

downreg_C48 <- resC48_df %>%
  filter(log2FoldChange < -1.5, padj < 0.05)

downreg_N24 <- resN24_df %>%
  filter(log2FoldChange < -1.5, padj < 0.05)

downreg_N48 <- resN48_df %>%
  filter(log2FoldChange < -1.5, padj < 0.05)
```

We can now add the COG terms to the dataframes.

```{r}
# Helper function to prevent a lot of boiler plate
add_cogs <- function(res) {
  df <- merge(res, annotation_data[, c("query", "COG_category")], by.x = "gene_id", by.y = "query", all.x = TRUE)
  return(df)
}
```

```{r}
# We apply our helper function to add COG terms
upreg_C24 <- add_cogs(upreg_C24)

upreg_C48 <- add_cogs(upreg_C48)

upreg_N24 <- add_cogs(upreg_N24)

upreg_N48 <- add_cogs(upreg_N48)

downreg_C24 <- add_cogs(downreg_C24)

downreg_C48 <- add_cogs(downreg_C48)

downreg_N24 <- add_cogs(downreg_N24)

downreg_N48 <- add_cogs(downreg_N48)
```

```{r}
# We need to filter out non matches.
upreg_C24 <- upreg_C24 %>%
  filter(COG_category != "-")

upreg_C48 <- upreg_C48 %>%
  filter(COG_category != "-")

upreg_N24 <- upreg_N24 %>%
  filter(COG_category != "-")

upreg_N48 <- upreg_N48 %>%
  filter(COG_category != "-")

downreg_C24 <- downreg_C24 %>%
  filter(COG_category != "-")

downreg_C48 <- downreg_C48 %>%
  filter(COG_category != "-")

downreg_N24 <- downreg_N24 %>%
  filter(COG_category != "-")

downreg_N48 <- downreg_N48 %>%
  filter(COG_category != "-")
```

```{r}
# Helper functions to create our bar charts
plot_cogs <- function(cog_frame, title) {
  cog_plot <- ggplot(data = cog_frame, aes(x = COG_category, fill = COG_category)) + 
  geom_bar(show.legend = FALSE) +  # remove legend for cleaner look
  scale_fill_viridis_d(option = "C") +
  labs(
    title = title,
    x = "COG Category",
    y = "Category Count"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
  return(cog_plot)
}
```

Charts for up-regulated COG categories.

```{r}
# creating our bar plots
cog_bar_c24 <- plot_cogs(upreg_C24, title = "Upregulated COGs: Cells vs. Control 24H")

cog_bar_c48 <- plot_cogs(upreg_C48, title = "Upregulated COGs: Cells vs. Control 48H")

cog_bar_n24 <- plot_cogs(upreg_N24, title = "Upregulated COGs: Supernatant vs. Control 24H")

cog_bar_n48 <- plot_cogs(upreg_N48, title = "Upregulated COGs: Supernatant vs. Control 48H")

# We can now save files
#ggsave("DEG_results/up_cogs_c24.png", plot = cog_bar_c24, dpi = 600, width = 10, height = 8)
#ggsave("DEG_results/up_cogs_c48.png", plot = cog_bar_c48, dpi = 600, width = 10, height = 8)
#ggsave("DEG_results/up_cogs_n24.png", plot = cog_bar_n24, dpi = 600, width = 10, height = 8)
#ggsave("DEG_results/up_cogs_n48.png", plot = cog_bar_n48, dpi = 600, width = 10, height = 8)

# Visualize our plots
cog_bar_c24
cog_bar_c48
cog_bar_n24
cog_bar_n48
```

Now we can plot the down-regulated COG terms.

```{r}
# Helper for downregulated cogs
plot_down_cogs <- function(cog_frame, title) {
  cog_plot <- ggplot(data = cog_frame, aes(x = COG_category, fill = COG_category)) + 
  geom_bar(show.legend = FALSE) +  # remove legend for cleaner look
  scale_fill_viridis_d(option = "D") +
  labs(
    title = title,
    x = "COG Category",
    y = "Category Count"
  ) +
  theme_minimal(base_size = 14) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, face = "bold"),
    axis.text.y = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    plot.title = element_text(face = "bold", hjust = 0.5)
  )
  return(cog_plot)
}
```

```{r}
# We can now create our bar plots
cog_bar_c24D <- plot_down_cogs(downreg_C24, title = "Downregulated COGs: Cells vs. Control 24")

cog_bar_c48D <- plot_down_cogs(downreg_C48, title = "Downregulated COGs: Cells vs. Control 48")

cog_bar_n24D <- plot_down_cogs(downreg_N24, title = "Downregulated COGs: Supernatant vs. Control 24")

cog_bar_n48D <- plot_down_cogs(downreg_N48, title = "Downregulated COGs: Supernatant vs. Control 48")

# save files
# ggsave("DEG_results/down_cogs_c24.png",
#        plot = cog_bar_c24D, dpi = 600, width = 10, height = 8)
# ggsave("DEG_results/down_cogs_c48.png",
#        plot = cog_bar_c48D, dpi = 600, width = 10, height = 8)
# ggsave("DEG_results/down_cogs_n24.png",
#        plot = cog_bar_n24D, dpi = 600, width = 10, height = 8)
# ggsave("DEG_results/down_cogs_n48.png",
#        plot = cog_bar_n48D, dpi = 600, width = 10, height = 8)

# plot to markdown
cog_bar_c24D
cog_bar_c48D
cog_bar_n24D
cog_bar_n48D
```

We can now extract the top up-regulated and down-regulated genes to get a better understanding of which genes see a strong change in expression and correlate them with the COG/GO terms to see which biological processes/functions are most impacted.

First we need to add in DIAMOND annotations to append names to our GOIs.

```{r}
# We load in our annotation file
# diamond_hits <- read.delim("filtered.tsv", sep = "\t", header = TRUE)

# We need to trim white space off the columns
diamond_hits$qseqid <- trimws(diamond_hits$qseqid)
diamond_hits$sseqid <- trimws(diamond_hits$sseqid)
diamond_hits$stitle <- trimws(diamond_hits$stitle)

# This is a helper function to add annotations to results dataframe
add_diamond_annotations <- function(res_df, diamond_df) {
  merge(res_df, diamond_df[, c("qseqid", "sseqid", "stitle")],
        by.x = "gene_id", by.y = "qseqid", all.x = TRUE) # uses a left join (all.x)
}

# We can now run our function for each data frame
DIAMOND_resC24_df <- add_diamond_annotations(resC24_df, diamond_hits)
DIAMOND_resC48_df <- add_diamond_annotations(resC48_df, diamond_hits)
DIAMOND_resN24_df <- add_diamond_annotations(resN24_df, diamond_hits)
DIAMOND_resN48_df <- add_diamond_annotations(resN48_df, diamond_hits)

# A helper function for adding a new column for labels
add_delabel_top50 <- function(df) {
  
  # We choose which genes to annotate by Log2FoldChange and p-values
  sig_genes <- df %>%
    filter(abs(log2FoldChange) > 1.5, padj < 0.05)
  
  # We create an object of top genes
  top50 <- sig_genes %>%
    arrange(padj) %>%
    slice_head(n = 10)
  
  # We can now apply our label
  df$delabel <- ifelse(df$sseqid %in% top50$sseqid, df$sseqid, NA)
  
  # Return the labeled data frame
  return(df)
}

# We apply the function to each data frame
DIAMOND_resC24_df <- add_delabel_top50(DIAMOND_resC24_df)
DIAMOND_resC48_df <- add_delabel_top50(DIAMOND_resC48_df)
DIAMOND_resN24_df <- add_delabel_top50(DIAMOND_resN24_df)
DIAMOND_resN48_df <- add_delabel_top50(DIAMOND_resN48_df)
```

Now we have to filter by top 20 and bottom 20 genes with cutoff values of lof2FoldChange of abs(1.5) and p-value 0.05

```{r}
# Helper functions to minimize boilerplate
top_filter <- function(annotated_df) {
  df <- annotated_df %>%
  filter(log2FoldChange > 1.5, padj < 0.05) %>%
  arrange(desc(log2FoldChange)) %>%
  slice_head(n = 20)
  return(df)
}

down_filter <- function(annotated_df) {
  df <- annotated_df %>%
  filter(log2FoldChange < -1.5, padj < 0.05) %>%
  arrange(desc(log2FoldChange)) %>%
  slice_head(n = 20)
  return(df)
}
```

```{r}
# Top 20 genes
C24_top20 <- top_filter(DIAMOND_resC24_df)

C48_top20 <- top_filter(DIAMOND_resC24_df)

N24_top20 <- top_filter(DIAMOND_resN24_df)

N48_top20 <- top_filter(DIAMOND_resN48_df)

# Bottom 20 genes
C24_bott20 <- down_filter(DIAMOND_resC24_df)

C48_bott20 <- down_filter(DIAMOND_resC48_df)

N24_bott20 <- down_filter(DIAMOND_resN24_df)

N48_bott20 <- down_filter(DIAMOND_resN48_df)
```

Now we can make some nicely formatted tables.

```{r}
# Helper function for table plotting
table_maker <- function(table_frame, title) {
  table <- table_frame %>%
  select(gene_id, log2FoldChange, padj, stitle) %>%
  gt() %>%
  tab_header(
    title = title
  ) %>%
  cols_label(
    gene_id = "Gene",
    log2FoldChange = "Log2 Fold Change",
    padj = "Adjusted P-Value",
    stitle = "DIAMOND Hit"
  )
  return(table)
}
```

```{r}
# top 20 tables
gt_C24 <- table_maker(C24_top20, title = "Top 20 Upregulated Genes: Cells 24H vs. Control")

gt_C48 <- table_maker(C48_top20, title = "Top 20 Upregulated Genes: Cells 48H vs. Control")

gt_N24 <- table_maker(N24_top20, title = "Top 20 Upregulated Genes: Supernatant 24H vs. Control")

gt_N48 <- table_maker(N48_top20, title = "Top Upregulated Genes: Supernatant 48H vs. Control")

# We can now visualize our tables
gt_C24
gt_C48
gt_N24
gt_N48
```

# Downreg tables

```{r}
# downregulated genes
gt_C24D <- table_maker(C24_bott20, title = "Top 20 Downregulated Genes: Cells 24H vs. Control")

gt_C48D <- table_maker(C48_bott20, title = "Top 20 Downregulated Genes: Cells 48H vs. Control")

gt_N24D <- table_maker(N24_bott20, title = "Top 20 Downregulated Genes: Supernatant 24H vs. Control")

gt_N48D <- table_maker(N48_bott20, title = "Top 20 Downregulated Genes: Supernatant 48H vs. Control")

# We can now visualize our tables
gt_C24D
gt_C48D
gt_N24D
gt_N48D
```

We can now save our tables to our results directory.

```{r, echo=FALSE,message=FALSE}
gtsave(gt_C24, "DEG_results/upregC24.png")
gtsave(gt_C48, "DEG_results/upregC48.png")
gtsave(gt_N24, "DEG_results/upregSuper24.png")
gtsave(gt_N48, "DEG_results/upregSuper48.png")

gtsave(gt_C24D, "DEG_results/downregC24.png")
gtsave(gt_C48D, "DEG_results/downregC48.png")
gtsave(gt_N24D, "DEG_results/downregN24.png")
gtsave(gt_N48D, "DEG_results/downregN48.png")
```
