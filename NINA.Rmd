---
title: "NINA Analysis: Pair-wise Comaprisons Against the Control"
author: "Javier"
date: "2025-04-14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Ease of life

include = FALSE prevents code and results from appearing in the finished file echo = FALSE prevents code, but not the results from appearing in the finished file message = FALSE prevents messages that are generated by code from appearing in the finished file warning = FALSE prevents warnings that are generated by code from appearing in the finished. fig.cap = "..." adds a caption to graphical results.

# Package Installation

The following code is used to download all libraries necessary for this analysis. Differential gene expression is performed using DEseq2 with plotting done with ggplot2 and ggVennDiagram.

```{r, echo = FALSE, message = FALSE}
### REQUIRED PACKAGES ###

# install bioconductor packages
if (!requireNamespace("BiocManager", quietly = TRUE))
  install.packages("BiocManager")
if (!requireNamespace("DESeq2", quietly = TRUE))
  BiocManager::install("DESeq2")
if (!requireNamespace("topGO", quietly = TRUE))
  BiocManager::install("topGO")

# install CRAN packages
if (!requireNamespace("ggVennDiagram", quietly = TRUE))
  install.packages("ggVennDiagram")
if (!requireNamespace("ggplot2", quietly = TRUE))
  install.packages("ggplot2")
if (!requireNamespace("dplyr", quietly = TRUE))
  install.packages("dplyr")
if (!requireNamespace("pheatmap", quietly = TRUE))
  install.packages("pheatmap")
```

# Loading Libraries

This section of code loads the necessary libraries.

```{r, echo = FALSE, message = FALSE}
# load libraries
library("DESeq2")
library("ggplot2")
library("ggVennDiagram")
library("dplyr")
library("pheatmap")
library("topGO")
```

# Data Import

The following code is used to import the data for DEG analysis. The text file produced from feature counts is imported as the raw table. The table is cleaned of unnecessary rows, ie meta-data.

The row names then need to be set for the genes list or else DESeq2 will not work. It only takes numbers as input and extra information not in the form of a column or row name will result in an error message.

The first column contains a set of numbers that corresponds to the row number and needs to be removed before the gene list can be assigned as the row name.

Coldata refers to column data, ie. the meta data needed to perform analysis. This table has information about each analyzed fastq file and the treatment it received. In my case this was control, nina treated at 24 and 48 hours, and treatment with bacterial cells for 24 and 48 hours.

Similarly to the featurecounts data, the column-data needed reformatting with row names corresponding to each fastq file in order.

The final line is a way to confirm that the columns in the feature count table correspond with the rows of the coldata table.

```{r, echo = FALSE}
### IMPORTING DATA ###

# analyzing count matrix
featurecounts_raw <- read.delim("feature_counts.txt",
                                sep = "\t",
                                header = TRUE) # import feature_counts
cleanfeatures <- featurecounts_raw[-c(2, 3, 4, 5, 6)] # cleans up columns

# set row names
counts <- cleanfeatures[, -1] # removes the first column
rownames(counts) <- cleanfeatures[, 1] # sets row names for counts

# import column data
coldata <- read.csv("coldata.csv", header = TRUE)

# set row names for coldata
rownames(coldata) <- coldata$X # the name of the column is X
```

# Column and Row Sanity Check

The following snippet of codes checks to see if columns and rows match for the coldata and cleaned and formatted counts matrix. If the following code prints FALSE, then go back and trouble shoot.

```{r}
# test to see if columns and rows match
all(rownames(coldata) == colnames(counts)) # should be true
```

# DEG Analysis

The following snippet of code performs the DEG analysis.

The first snippet creates an object called dds, ie. DESeqDataSet. The parameters include the data, in this case it was the counts object we created in the last code block with the gene list as the row names. The column data is the coldata object we created and reformatted. Finally, the design includes the column name for the coldata object holding our experimental design, ie. treatment type.

The second line of code sets the control group as the reference for comparison.

```{r, echo = FALSE}
### DEG ANALYSIS ###

# creates a DeseqDataSet or DDS
dds <- DESeqDataSetFromMatrix(countData = counts,
                              colData = coldata,
                              design = ~ Treatment)

# sets the comparisons, in this case the coldata column name is Treatment,
# the reference is named control
dds$Treatment <- relevel(dds$Treatment, ref = "control")

# no clue what this does, manual said to tho
# prints the dataframe i suppose?
dds

# performs DEG
dds <- DESeq(dds)

# creates a results dataframe
results <- results(dds)
```

# Sanity Check for Sucessful DEG Analysis

The following code prints all results, double check and make sure the proper comparisons were made and trouble shoot if need be.

```{r}
# prints results
results

# prints summary of results
summary(results)

# prints pairwise comparisons,useful double check
resultsNames(dds)
```

# PCA Plot

The following snippet of code is crucial for testing the quality of our data.

The first line of code creates an object called vsd. I do not remember why I chose vsd, I think it might have been variance stablizied data but I am not sure. In any case, the line of code is taking the dds object with our differential expression analysis data and applying the method vst to it. vst is one of the variance stablizing functions provided by DESeq2 that allows for the creation of PCA plots. By default, the vst method used the top 500 genes in terms of variance for the analysis. You can modify this using the ntop = foo option, The blind = TRUE option is important, as it allows you to see the variance across groups.

The next line of code creates an object called pca_data that stored the output from the plotPCA method provided by DESEq2. It uses our vsd object, intgroup refers to experimental design, and returnData = TRUE does something important I presume.

Finally, the next line of code creates an object percent_var that stores the percent variance extracted from the pcr_data.

```{r}
### RUN THIS FIRST AFTER DEG TO ENSURE QUALITY ###

# creates an output directory
dir.create("DEG_results", showWarnings = FALSE)

# VST transformation
vsd <- vst(dds, blind = TRUE)
pca_data <- plotPCA(vsd, intgroup = c("Treatment"), returnData = TRUE)
percent_var <- round(100 * attr(pca_data, "percentVar"))

# PCA plotting using ggplot2
pca <- ggplot(pca_data, aes(PC1, PC2, color = Treatment)) +
  geom_point(size = 3, alpha = 0.8) +
  xlab(paste0("PC1: ", percent_var[1], "% variance")) +
  ylab(paste0("PC2: ", percent_var[2], "% variance")) +
  coord_fixed() +
  scale_color_brewer(palette = "Set1") +
  theme_minimal(base_size = 14) +
  theme(panel.background = element_rect(fill = "white")) +
  theme(
    legend.position = "right",
    legend.title = element_text(face = "bold"),
    axis.title = element_text(face = "bold"),
    axis.text = element_text(color = "black"),
    panel.grid.major = element_line(color = "gray90"),
    panel.grid.minor = element_blank()
  )

# save plot as a png
ggsave("DEG_results/pca_plot.png", plot = pca, width = 6, height = 6, dpi = 300)

# print to r markdown
pca
```

# Venn Diagrams

Since our quality was all good, we can start creating some plots to represent our data.

```{r}
# creates an output directory
dir.create("DEG_results", showWarnings = FALSE)

# list to store genes
comparisons <- resultsNames(dds)[-1] # removes the first weird column
all_degs <- list()

# loop through pair-wise comparison
for (comp in comparisons) {
  res <- results(dds, name = comp) #saves results for each comparison
  sig <- res[which(res$padj < 0.05 & !is.na(res$padj)), ] # filter for p and NA

  up <- rownames(sig[sig$log2FoldChange > 1.5, ]) # filter for up-reg 1.5
  down <- rownames(sig[sig$log2FoldChange < -1.5, ]) # filter for down-red -1.5

  all_degs[[comp]] <- up # compile up-reg genes
  all_degs[[comp]] <- down # compile down-reg genes
}

# todos los genes arriba y abajo
all_venn <- ggVennDiagram(all_degs, label_alpha = 0, edge_size = 0.5,
                          label = "count",
                          label_size = 5,
                          category.names = c("Cells vs. Control 24H",
                                             "Cells vs. Control 48H",
                                             "NINA vs. Control 24H",
                                             "NINA vs. Control 48H")) +
  theme(panel.background = element_rect(fill = "white")) +
  scale_fill_distiller(palette = "Spectral") +
  labs(title = "All Differentially Expressed Genes") +
  theme(text = element_text(size = 10),
        plot.title = element_text(size = 14, hjust = 0.5, face = "bold"))

# fixes the long labels
fixed_venn <- all_venn + scale_x_continuous(expand = expansion(mult = 0.2))

ggsave("DEG_results/all_DEGs_venn.png",
       plot = fixed_venn, width = 8, height = 6, dpi = 300)
# plot to markdown
fixed_venn
```

# Extraction of Indiviudal Comparisons

Some of the following analyses involve the inividual pair-wise comparisons, so in this section I am extracting them and stored them as dataframes.

```{r, echo = FALSE}
# store comparison names
cell_24_control <- resultsNames(dds)[-c(1,3,4,5)] # this part is pretty confusing
cell_48_control <- resultsNames(dds)[-c(1,2,4,5)] # what i am doing is removing..
nina_24_control <- resultsNames(dds)[-c(1,2,3,5)] # the different indices to leave..
nina_48_control <- resultsNames(dds)[-c(1,2,3,4)] # the one I am interested in

#saves results for each comparison
resC24 <- results(dds, name = cell_24_control)
resC48 <- results(dds, name = cell_48_control) 
resN24 <- results(dds, name = nina_24_control)
resN48 <- results(dds, name = nina_48_control)

#filter the data for NA values
resC24_df <- as.data.frame(resC24) %>% # pipe operator, the same as | foo | in bash
  filter(!is.na(log2FoldChange), !is.na(padj))
resC48_df <- as.data.frame(resC48) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))
resN24_df <- as.data.frame(resN24) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))
resN48_df <- as.data.frame(resN48) %>%
  filter(!is.na(log2FoldChange), !is.na(padj))

# add columns for up, down, and no-sig
resC24_df$diffexpress <- "NO" # initializes column with no as default
resC24_df$diffexpress[resC24_df$padj < 0.05 & resC24_df$log2FoldChange > 1.5] <- "UP"
resC24_df$diffexpress[resC24_df$padj < 0.05 & resC24_df$log2FoldChange < -1.5] <- "DOWN"
resC48_df$diffexpress <- "NO" # initializes column with no as default
resC48_df$diffexpress[resC48_df$padj < 0.05 & resC48_df$log2FoldChange > 1.5] <- "UP"
resC48_df$diffexpress[resC48_df$padj < 0.05 & resC48_df$log2FoldChange < -1.5] <- "DOWN"
resN24_df$diffexpress <- "NO" # initializes column with no as default
resN24_df$diffexpress[resN24_df$padj < 0.05 & resN24_df$log2FoldChange > 1.5] <- "UP"
resN24_df$diffexpress[resN24_df$padj < 0.05 & resN24_df$log2FoldChange < -1.5] <- "DOWN"
resN48_df$diffexpress <- "NO" # initializes column with no as default
resN48_df$diffexpress[resN48_df$padj < 0.05 & resN48_df$log2FoldChange > 1.5] <- "UP"
resN48_df$diffexpress[resN48_df$padj < 0.05 & resN48_df$log2FoldChange < -1.5] <- "DOWN"

# convert row names to columns
resC24_df$gene_id <- rownames(resC24_df)
resC48_df$gene_id <- rownames(resC48_df)
resN24_df$gene_id <- rownames(resN24_df)
resN48_df$gene_id <- rownames(resN48_df)
```

# Volcano Plots

These are classic for DEG analysis, Kaleb said to make one too so here goes nothing. I followed a tutorial from biostatsquid and the plots are made with ggplot2 and dply for data wrangling. Very useful tutorial btw, I learned that ggplot2 adds elements as you place them in the script. Like the layers of an onion.

Also, if you do ggplot2(foo) it works differently than ggplot2(data = foo).

```{r}
# creates a basic volcano plot as a starting point
volc_cells_24 <- ggplot(data = resC24_df, 
                        aes(x = log2FoldChange, y = -log10(padj), col = diffexpress)) +
  geom_vline(xintercept = c(-1.5, 1.5), col = "gray", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = "dashed") +
  geom_point(size = 2) +
  scale_color_manual(values = c("blue","grey","red"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) +
  coord_cartesian(ylim = c(0, 40), xlim = c(-10, 10)) +
  labs(color = "Legend", x = expression("log"[2]*"FC"), y = expression("-log"[10]*"Adjusted p-value")) +
  ggtitle("Cells vs. Control 24H")

volc_cells_48 <- ggplot(data = resC48_df, 
                        aes(x = log2FoldChange, y = -log10(padj), col = diffexpress)) +
  geom_vline(xintercept = c(-1.5, 1.5), col = "gray", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = "dashed") +
  geom_point(size = 2) +
  scale_color_manual(values = c("blue","grey","red"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) +
  coord_cartesian(ylim = c(0, 40), xlim = c(-10, 10)) +
  labs(color = "Legend", x = expression("log"[2]*"FC"), y = expression("-log"[10]*"Adjusted p-value")) +
  ggtitle("Cells vs. Control 48H")

volc_NINA_24 <- ggplot(data = resN24_df, 
                       aes(x = log2FoldChange, y = -log10(padj), col = diffexpress)) +
  geom_vline(xintercept = c(-1.5, 1.5), col = "gray", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = "dashed") +
  geom_point(size = 2) +
  scale_color_manual(values = c("blue","grey","red"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) +
  coord_cartesian(ylim = c(0, 40), xlim = c(-10, 10)) +
  labs(color = "Legend", x = expression("log"[2]*"FC"), y = expression("-log"[10]*"Adjusted p-value")) +
  ggtitle("NINA vs. Control 24H")

volc_NINA_48 <- ggplot(data = resN48_df, 
                       aes(x = log2FoldChange, y = -log10(padj), col = diffexpress)) +
  geom_vline(xintercept = c(-1.5, 1.5), col = "gray", linetype = "dashed") +
  geom_hline(yintercept = -log10(0.05), col = "gray", linetype = "dashed") +
  geom_point(size = 2) +
  scale_color_manual(values = c("blue","grey","red"),
                     labels = c("Downregulated", "Not significant", "Upregulated")) +
  coord_cartesian(ylim = c(0, 40), xlim = c(-10, 10)) +
  labs(color = "Legend", x = expression("log"[2]*"FC"), y = expression("-log"[10]*"Adjusted p-value")) +
  ggtitle("NINA vs. Control 48H")

# save plots
ggsave("DEG_results/volc_cells_24.png",
       plot = volc_cells_24, width = 8, height = 6, dpi = 300)
ggsave("DEG_results/volc_cells_48.png",
       plot = volc_cells_48, width = 8, height = 6, dpi = 300)
ggsave("DEG_results/volc_NINA_24.png",
       plot = volc_NINA_24, width = 8, height = 6, dpi = 300)
ggsave("DEG_results/volc_NINA_48.png",
       plot = volc_NINA_48, width = 8, height = 6, dpi = 300)

# plot to markdown
volc_cells_24
volc_cells_48
volc_NINA_24
volc_NINA_48
```

# GO Analysis-Prep

The next bits of code are my attempts at GO analysis. GO terms were found using InterProScan command line tool. The first code chunk is prepping data and creating gene universe.


```{r}
# Import and clean go terms from InterProscan output
raw_goterms <- read.csv("cleaned_gos.tsv", sep = "\t", header = TRUE)

raw_goterms$go_terms <- gsub("InterPro", "", raw_goterms$go_terms)
raw_goterms$go_terms <- gsub("PANTHER", "", raw_goterms$go_terms)
raw_goterms$go_terms <- gsub("\\(\\)", "", raw_goterms$go_terms) # this is some weird regex shenanigans you have to deal with, the \ helps you escape from special characters. So you need one \ to escape from the next backslash, then the next \ helps you escape from the ( and the next two \\ do that same for ). It is really silly but its what chatgpt said to do so whatever
raw_goterms$go_terms <- gsub("\\|", ",", raw_goterms$go_terms)

raw_goterms <- raw_goterms[, c("gene_id", "go_terms")]
write.table(raw_goterms, file = "formatted_gos.tsv", sep = "\t",
            row.names = FALSE, col.names = FALSE, quote = FALSE)

# Importing the table back in as a gene-2-go object
gene2goMappings <- readMappings(file = "formatted_gos.tsv", sep = "\t", IDsep = ",")
```

# GO Analysis Prep 2

Extracting gene IDs and p-values

```{r}
# Extract gene IDs and p-values
Cp24 <- dplyr::select(resC24_df, gene_id,padj)
Cp48 <- dplyr::select(resC48_df, gene_id,padj)
Np24 <- dplyr::select(resN24_df, gene_id,padj)
Np48 <- dplyr::select(resN48_df, gene_id,padj)

# sort by p-value
sorted_Cp24 <- Cp24[order(Cp24$padj),]
sorted_Cp48 <- Cp48[order(Cp48$padj),]
sorted_Np24 <- Np24[order(Np24$padj),]
sorted_Np48 <- Np48[order(Np48$padj),]

# convert to topGOs genelist format
topgo_Cp24 <- sorted_Cp24$padj
topgo_Cp48 <- sorted_Cp48$padj
topgo_Np24 <- sorted_Np24$padj
topgo_Np48 <- sorted_Np48$padj

names(topgo_Cp24) <- sorted_Cp24$gene_id
names(topgo_Cp48) <- sorted_Cp48$gene_id
names(topgo_Np24) <- sorted_Np24$gene_id
names(topgo_Np48) <- sorted_Np48$gene_id

# Fishers Test parameters
top5C24 <- quantile(x=topgo_Cp24, probs=0.05)
top5C48 <- quantile(x=topgo_Cp48, probs=0.5)
top5N24 <- quantile(x=topgo_Np24, probs=0.05)
top5N48 <- quantile(x=topgo_Np48, probs=0.05)
```

# GO analysis

Building topGOdata object using MF ontology.

```{r, echo=FALSE, message=FALSE}
# Fishers test functions
top5C24_func <- function(x) {
  return(x <= top5C24)
}

top5C48_func <- function(x) {
  return(x <= top5C48)
}

top5N24_func <- function(x) {
  return(x <= top5N24) 
}

top5N48_func <- function(x) {
  return(x <= top5N48)
}

# creating GO data objects for molecular function
Cp24_go_mf <- new("topGOdata", 
               ontology = "MF", 
               allGenes = topgo_Cp24, 
               annot = annFUN.gene2GO, 
               geneSel = top5C24_func,
               gene2GO = gene2goMappings)

Cp48_go_mf <- new("topGOdata",
               ontology = "MF",
               allGenes = topgo_Cp48,
               annot = annFUN.gene2GO,
               geneSel = top5C48_func,
               gene2GO = gene2goMappings)

Np24_go_mf <- new("topGOdata",
               ontology = "MF",
               allGenes = topgo_Np24,
               annot = annFUN.gene2GO,
               geneSel = top5N24_func,
               gene2GO = gene2goMappings)

Np48_go_mf <- new("topGOdata",
               ontology = "MF",
               allGenes = topgo_Np48,
               annot = annFUN.gene2GO,
               geneSel = top5N48_func,
               gene2GO = gene2goMappings)

# creating GO data objects for biological process
Cp24_go_bp <- new("topGOdata", 
               ontology = "BP", 
               allGenes = topgo_Cp24, 
               annot = annFUN.gene2GO, 
               geneSel = top5C24_func,
               gene2GO = gene2goMappings)

Cp48_go_bp <- new("topGOdata",
               ontology = "BP",
               allGenes = topgo_Cp48,
               annot = annFUN.gene2GO,
               geneSel = top5C48_func,
               gene2GO = gene2goMappings)

Np24_go_bp <- new("topGOdata",
               ontology = "BP",
               allGenes = topgo_Np24,
               annot = annFUN.gene2GO,
               geneSel = top5N24_func,
               gene2GO = gene2goMappings)

Np48_go_bp <- new("topGOdata",
               ontology = "BP",
               allGenes = topgo_Np48,
               annot = annFUN.gene2GO,
               geneSel = top5N48_func,
               gene2GO = gene2goMappings)

# creating GO data objects for cellular component
Cp24_go_cc <- new("topGOdata", 
               ontology = "CC", 
               allGenes = topgo_Cp24, 
               annot = annFUN.gene2GO, 
               geneSel = top5C24_func,
               gene2GO = gene2goMappings)

Cp48_go_cc <- new("topGOdata",
               ontology = "CC",
               allGenes = topgo_Cp48,
               annot = annFUN.gene2GO,
               geneSel = top5C48_func,
               gene2GO = gene2goMappings)

Np24_go_cc <- new("topGOdata",
               ontology = "CC",
               allGenes = topgo_Np24,
               annot = annFUN.gene2GO,
               geneSel = top5N24_func,
               gene2GO = gene2goMappings)

Np48_go_cc <- new("topGOdata",
               ontology = "CC",
               allGenes = topgo_Np48,
               annot = annFUN.gene2GO,
               geneSel = top5N48_func,
               gene2GO = gene2goMappings)
```

# Running Fisher's Test for Enrichment and Plotting

```{r, echo=FALSE,message=FALSE}
# Enrichment tests for Molecular Function
enrich_Cp24_mf <- runTest(Cp24_go_mf, algorithm = "classic", statistic = "fisher")
enrich_Cp48_mf <- runTest(Cp48_go_mf, algorithm = "classic", statistic = "fisher")
enrich_Np24_mf <- runTest(Np24_go_mf, algorithm = "classic", statistic = "fisher")
enrich_Np48_mf <- runTest(Np48_go_mf, algorithm = "classic", statistic = "fisher")

# Enrichment tests for Biological Process
enrich_Cp24_bp <- runTest(Cp24_go_bp, algorithm = "classic", statistic = "fisher")
enrich_Cp48_bp <- runTest(Cp48_go_bp, algorithm = "classic", statistic = "fisher")
enrich_Np24_bp <- runTest(Np24_go_bp, algorithm = "classic", statistic = "fisher")
enrich_Np48_bp <- runTest(Np48_go_bp, algorithm = "classic", statistic = "fisher")

# Enrichment tests for Cellular Component
enrich_Cp24_cc <- runTest(Cp24_go_cc, algorithm = "classic", statistic = "fisher")
enrich_Cp48_cc <- runTest(Cp48_go_cc, algorithm = "classic", statistic = "fisher")
enrich_Np24_cc <- runTest(Np24_go_cc, algorithm = "classic", statistic = "fisher")
enrich_Np48_cc <- runTest(Np48_go_cc, algorithm = "classic", statistic = "fisher")
```

# Generating a Table for Plotting

```{r, echo=FALSE,message=FALSE}
# Function to generate a nicely formatted enrichment table
get_enrich_table <- function(go_obj, test_result, top_n = 10) {
  tab <- GenTable(go_obj,
                  classicFisher = test_result,
                  topNodes = top_n) %>%
    dplyr::mutate(pval = as.numeric(classicFisher),
                  Term = factor(Term, levels = rev(Term)),
                  Count = as.numeric(Significant))  # Important: convert 'Significant' to numeric
  return(tab)
}

# Molecular Function (MF)
tab_Cp24_mf <- get_enrich_table(Cp24_go_mf, enrich_Cp24_mf)
tab_Cp48_mf <- get_enrich_table(Cp48_go_mf, enrich_Cp48_mf)
tab_Np24_mf <- get_enrich_table(Np24_go_mf, enrich_Np24_mf)
tab_Np48_mf <- get_enrich_table(Np48_go_mf, enrich_Np48_mf)

# Biological Process (BP)
tab_Cp24_bp <- get_enrich_table(Cp24_go_bp, enrich_Cp24_bp)
tab_Cp48_bp <- get_enrich_table(Cp48_go_bp, enrich_Cp48_bp)
tab_Np24_bp <- get_enrich_table(Np24_go_bp, enrich_Np24_bp)
tab_Np48_bp <- get_enrich_table(Np48_go_bp, enrich_Np48_bp)

# Cellular Component (CC)
tab_Cp24_cc <- get_enrich_table(Cp24_go_cc, enrich_Cp24_cc)
tab_Cp48_cc <- get_enrich_table(Cp48_go_cc, enrich_Cp48_cc)
tab_Np24_cc <- get_enrich_table(Np24_go_cc, enrich_Np24_cc)
tab_Np48_cc <- get_enrich_table(Np48_go_cc, enrich_Np48_cc)
```

# Plotting Bar Plot

```{r}
# Plotting function
plot_enrich_bar <- function(enrich_tab, title) {
  ggplot(enrich_tab, aes(x = Term, y = Count, fill = pval)) +
    geom_bar(stat = "identity") +
    coord_flip() +
    scale_fill_gradient(low = "red", high = "blue", name = "p-value", trans = "reverse") +
    labs(title = title,
         x = "GO Term",
         y = "Gene Count") +
    theme_minimal()
}

# MF plots
plot_enrich_bar(tab_Cp24_mf, "GO Enrichment: MF Cells vs. Control 24H")
plot_enrich_bar(tab_Cp48_mf, "GO Enrichment: MF Cells vs. Control 48H")
plot_enrich_bar(tab_Np24_mf, "GO Enrichment: MF Frankia vs. Control 24H")
plot_enrich_bar(tab_Np48_mf, "GO Enrichment: MF Frankia vs. Control 48H")

# BP plots
plot_enrich_bar(tab_Cp24_bp, "GO Enrichment: BP Cells vs. Control 24H")
plot_enrich_bar(tab_Cp48_bp, "GO Enrichment: BP Cells vs. Control 48H")
plot_enrich_bar(tab_Np24_bp, "GO Enrichment: BP Frankia vs. Control 24H")
plot_enrich_bar(tab_Np48_bp, "GO Enrichment: BP Frankia vs. Control 48H")

# CC plots
plot_enrich_bar(tab_Cp24_cc, "GO Enrichment: CC Cells vs. Control 24H")
plot_enrich_bar(tab_Cp48_cc, "GO Enrichment: CC Cells vs. Control 48H")
plot_enrich_bar(tab_Np24_cc, "GO Enrichment: CC Frankia vs. Control 24H")
plot_enrich_bar(tab_Np48_cc, "GO Enrichment: CC Frankia vs. Control 48H")
```


